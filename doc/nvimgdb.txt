*nvimgdb.txt*  GDB, LLDB, PDB/PDB++ and BASHDB integration into neovim

NvimGdb is a plugin to facilitate debugging native and interpreted programs.

==============================================================================
CONTENTS                                                     *NvimgdbContents*

    1. Usage ................ |NvimgdbUsage|
    2. Commands ............. |NvimgdbCommands|
    3. Mappings ............. |NvimgdbMappings|
    4. Variables ............ |NvimgdbVariables|
    5. Events ............... |NvimgdbEvents|
    6. Functions ............ |NvimgdbFunctions|
    7. Backends ............. |NvimgdbBackends|
       7.1 GDB .............. |NvimgdbGDB|
    8. Limitations .......... |NvimgdbLimitations|
    9. Development .......... |NvimgdbDevelopment|
   10. Trivia ............... |NvimgdbTrivia|

==============================================================================
Section 1: Usage                                                *NvimgdbUsage*

This plugin will facilitate debugging programs with GDB, LLDB, PDB/PDB++ or
BASHDB. It will automatically show debugged source code, breakpoints, and
define convenient keymaps similar to Qt Creator and Microsoft Visual Studio.

To start debugging, execute `:GdbStart` command with GDB launch string as
parameter: >

    :GdbStart gdb -q a.out

or alternatively `:GdbStartLLDB` with LLDB launch string as parameter: >

    :GdbStartLLDB lldb a.out

To debug Python programs, execute `:GdbStartPDB` and specify the python launch
command as parameter: >

    :GdbStartPDB python -m pdb main.py

To debug a Bash script, execute `:GdbStartBashDB` and specify the bashdb
launch command as parameter: >

    :GdbStartBashDB bashdb main.sh

This will open a new tab with debugging view: horizontal split with source
code and terminal. Then the whole set of commands will be available.

The plugin performs configuration on the first stop of the debugger. If you
launch by attaching to already running program, the first stop won't open the
source code location of the frame. To catch up, just navigate around the call
stack with `:GdbFrameUp` and `:GdbFrameDown`.

To quit debugging, either close the tabpage with the debugging session or
execute the command `:GdbDebugStop`.

==============================================================================
Section 2: Commands                                          *NvimgdbCommands*

                                                                   *:GdbStart*
:GdbStart [command]     Start debugging session with the given GDB launch
                        command.

                                                               *:GdbStartLLDB*
:GdbStartLLDB [cmd]     Start debugging session with the given LLDB launch
                        command.

                                                                *:GdbStartPDB*
:GdbStartPDB [cmd]      Start Python debugging session with the given PDB
                        launch command.

                                                             *:GdbStartBashDB*
:GdbStartBashDB [cmd]   Start Bash debuggin session with the given BASHDB
                        launch command.

                                                               *:GdbDebugStop*
:GdbDebugStop           Quit the debugging session. This command is implicitly
                        executed if you close either of the windows created by
                        the debugger.

                                                        *:GdbBreakpointToggle*
                                                      *:GdbBreakpointClearAll*
:GdbBreakpointToggle    Manage breakpoints in the code: toggle, clear all
:GdbBreakpointClearAll

                                                                *:GdbContinue*
                                                                    *:GdbNext*
                                                                    *:GdbStep*
                                                                  *:GdbFinish*
                                                                   *:GdbUntil*
:GdbContinue            Continue execution
:GdbNext                Step over next statement
:GdbStep                Step into next statement
:GdbFinish              Step out current stack frame
:GdbUntil [line]        (lldb,gdb) Continue execution until [line]
                        (pdb) Continue execution until the next
                        line number

                                                                 *:GdbFrameUp*
                                                               *:GdbFrameDown*
:GdbFrameUp             Navigate up/down one stack frame
:GdbFrameDown

                                                               *:GdbInterrupt*
:GdbInterrupt          Break program execution into the debugger

                                                                *:GdbEvalWord*
                                                               *:GdbEvalRange*
:GdbEvalWord           Evaluate |<cword>| or |[range]|
:<range>GdbEvalRange

                                                             *:GdbCreateWatch*
:GdbCreateWatch [command]
                       Create a new watch window with the [command] to be
                       evaluated using `GdbCustomCommand()` on every debug
                       prompt when the event `NvimGdbQuery` fires.

==============================================================================
Section 3: Mappings                                          *NvimgdbMappings*

The following mappings are defined initially unless the global variable
g:nvimgdb_disable_start_keymaps is defined and evaluates to true:

<leader>dd             Fill in command to start debugging with GDB, you will
                       still need to enter <cr> to execute it.

<leader>dl             Fill in command to start debugging with LLDB, you will
                       still need to enter <cr> to execute it.

<leader>dp             Fill in command to start debugging with PDB, you will
                       still need to enter <cr> to execute it.

<leader>db             Fill in command to start debugging with BASHDB, you will
                       still need to enter <cr> to execute it.

When debugging session has started, the following mappings are defined:

<f4>                   Until                          (`:GdbUntil`)
<f5>                   Continue                       (`:GdbContinue`)
<f10>                  Next                           (`:GdbNext`)
<f11>                  Step                           (`:GdbStep`)
<f12>                  Finish                         (`:GdbFinish`)
<f8>                   Toggle breakpoint              (`:GdbBreakpointToggle`)
<c-p>                  Frame Up                       (`:GdbFrameUp`)
<c-n>                  Frame Down                     (`:GdbFrameDown`)
<f9>                   NORMAL: Evaluate word under cursor (`:GdbEvalWord`)
                       VISUAL: Evaluate the range         (`:GdbEvalRange`)

==============================================================================
Section 4: Variables                                        *NvimgdbVariables*

If the variable g:nvimgdb_disable_start_keymaps is defined and evaluates to
true, the initial keymaps to start debugging session are suppressed
(see |NvimgdbMappings|).

The following variables could be defined to change default mappings for the
debugging commands: >

    g:nvimgdb_config
    g:nvimgdb_config_override
<
These variables are dictionaries with the keys described below. While the
first redefines the default configuration completely, the second one merely
allows overriding the given keys. For example, the default config is: >

    let g:nvimgdb_config = {
      \ 'key_until':      '<f4>',
      \ 'key_continue':   '<f5>',
      \ 'key_next':       '<f10>',
      \ 'key_step':       '<f11>',
      \ 'key_finish':     '<f12>',
      \ 'key_breakpoint': '<f8>',
      \ 'key_frameup':    '<c-p>',
      \ 'key_framedown':  '<c-n>',
      \ 'key_eval':       '<f9>',
      \ 'key_quit':       None,
      \ 'set_tkeymaps':   'function("GdbCallAsync", "keymaps.set_t")',
      \ 'set_keymaps':    'function("GdbCallAsync", "keymaps.set")',
      \ 'unset_keymaps':  'function("GdbCallAsync", "keymaps.unset")',
      \ 'sign_current_line': '▶',
      \ 'sign_breakpoint': [ '●', '●²', '●³', '●⁴', '●⁵', '●⁶', '●⁷', '●⁸', '●⁹', '●ⁿ' ],
      \ 'codewin_command': 'new'
      \ }
<
The key `codewin_command` defines a Vim command to create a new empty window
for the code view. It should produce one focused window, and could be used to
build desired layout.

The keys starting with `sign_` define how the signs for the currently executed
line and breakpoints look like. The default values assume a modern terminal
capable of rendering the Unicode superscript numbers, and fonts supporting
those symbols. It's possible to use other symbols too: >

    let g:nvimgdb_config_override = {
      \ 'sign_current_line': '>',
      \ 'sign_breakpoint': [ '*', '#' ],
      \ }
<
In this case the currently executed line will be signed with `>`, whereas a
single breakpoint with `*` and a duplicate breakpoint with `#`.

The keys starting with `key_` define a key mapping for the respective command.
The key `set_tkeymaps` allows specifying a hook function, which will be called
when the terminal window has been created.  The function is specified as a
string value.  It should correspond to either a Vim function.
You can call the default handler from within the hook and/or define your own
very specific terminal keymaps.  The keys `set_keymaps` and `unset_keymaps`
are called every time when the source code windows is entered and left.  The
first one can be used to define source window-specific keymaps and the latter
to carefully cleanup them.  See `test/init.vim` for an example.

Finally, every configuration key can be overridden with a global variable
prefixed `g:nvimgdb_`.  For example, `g:nvimgdb_key_next` overrides
`g:nvimgdb_config["key_next"]` etc.

Any conflicting keymap in the user-supplied configuration will be ignored by
the program.  The order in which the keymaps are examined is undefined.
However, the configuration from `g:nvimgdb_config_override` assumes priority
over default and `g:nvimgdb_config`.  And specific variables `g:nvimgdb_key_*`
have even higher priority and will disable conflicting keymaps from the
previous ones.  Please examine `:messages` to make sure nothing is rejected.

==============================================================================
Section 5: Events                                              *NvimgdbEvents*

The plugins fires `User` events allowing users to customize their workflows.
For instance, it's possible to execute commands automatically with `autocmd`.

                                                                *NvimGdbQuery*
NvimGdbQuery            Fired whenever the plugin queried for breakpoints.
                        This can be used to execute additional queries
                        with `GdbCustomCommand()`

                                                                *NvimGdbBreak*
NvimGdbBreak            Fired whenever the programm is paused.

                                                             *NvimGdbContinue*
NvimGdbContinue         Fired whenever the program is resumed after it has
                        been paused.

                                                                *NvimGdbStart*
NvimGdbStart            Fired when the debugging session starts.

                                                              *NvimGdbCleanup*
NvimGdbCleanup          Fired before the debugging session ends.

==============================================================================
Section 6: Functions                                        *NvimgdbFunctions*

The plugin is implemented Python using the remote plugin API.

                                                          *GdbCustomCommand()*
GdbCustomCommand("cmd")
                        Execute debugger command and return the output of the
                        command.  This can be combined with `NvimgdbEvents` to
                        implement watch expressions. For instance, the
                        following could echo local variables on every GDB
                        stop: >
    :autocmd User NvimGdbQuery echo GdbCustomCommand('info locals')
<
or if LLDB is used: >
    :autocmd User NvimGdbQuery echo GdbCustomCommand('frame var')
<
Such autocommand could update buffer contents on every debugger stop.  Assume
you created a new window displaying the buffer bufnum. Then try the following:
>
    :autocmd User NvimGdbQuery call nvim_buf_set_lines(bufnum, 0, -1, 0,
        \ split(GdbCustomCommand("info locals"), "\n"))
<

==============================================================================
Section 7: Backends                                          *NvimgdbBackends*

------------------------------------------------------------------------------
Section 7.1 GDB                                                   *NvimgdbGDB*

- GDB is run via a proxy pty application, which allows to execute concealed
  service commands, like "info breakpoints" on each stop. Thus, the plugin
  is able to very carefully display current set of breakpoints with the
  temporal ones disappearing after hit. Technically, the proxy app is a python
  program that launches gdb in a pseudo terminal, listens a unix socket for
  commands, and processes the output of GDB to filter out service commands.

- The compiler may embed relative paths to the source code files. Thus, the
  plugin may struggle to find them on the file system when identifying
  breakpoints. So consider working from within the same directory that was
  used to compile. Or alternatively, configure GCC to embed full paths: >

      gcc -fdebug-prefix-map=..=$(readlink -f ..)
<

==============================================================================
Section 8: Limitations                                    *NvimgdbLimitations*

- The plugin is sensitive to the debugger settings. If prompt or frame format
  is changed, random errors may occur.

- LLDB uses the same frame format in multiple different situations. The
  command "thread backtrace", for instance, will cause jumps in the source
  code. Workaround: execute "frame info" in the debugger or
  `:GdbFrameUp` followed by `:GdbFrameDown`.

==============================================================================
Section 9: Development                                    *NvimgdbDevelopment*

                                                              *NvimgdbLogging*
- To enable logging, edit the conventional Python logging configuration file
  ../rplugin/python3/gdb/logger.py

- The keymaps are defined buffer-local for every buffer when it's entered,
  and undefined when a buffer is left. This was done to ensure that users's
  aren't overridden in long term. However, a more general solution could be
  to ensure the original keymaps are preserved and restored after debugging
  session: https://vi.stackexchange.com/questions/7734/how-to-save-and-restore-a-mapping

- LLDB, PDB and BASHDB like GDB run via a proxy application. Although, they
  don't have a stock distinctive prefix to bypass the history.

- Breakpoints are queried from GDB, LLDB and PDB on every pause using the
  established side channels: the pty proxy for GDB, LLDB, PDB and BASHDB.
  The communication is done via unix domain sockets (see
  rplugin/python3/gdb/breakpoint.py).

==============================================================================
Section 10: Trivia                                             *NvimgdbTrivia*

License inherits from neovim's.

Patches are welcome to https://github.com/sakhnik/nvim-gdb.vim

The original version was taken from nvim source code (Thiago de Arruda)
https://github.com/neovim/neovim/blob/master/contrib/gdb/neovim_gdb.vim

 vim: set tw=78 ts=8 ft=help norl:
